/************************************************************************************************* Author: Devan Shah* Student ID : 100428864* Assignment: Assignment 3* Course: Programming Language and Compilers ENGR-3960U* Submitted to: Dr. Jorge Landa* Descriptions: In this assignment I have implemented the lexical and syntactic analysis of				Minifun programming language. The scanner splits up the inputs into tokens and				is used to catch lexical errors, which include invalid tokens that have been				inputed. The parser is used to check that the input list of tokens conforms to a				syntax that is specified with the use of the context-free grammar.************************************************************************************************/options{  STATIC = true;}PARSER_BEGIN(Parser)package main;import java.io.*;import java.util.*;public class Parser{  /* main function that is used to start the parsing of the inputed file and also deliver   * any error messages that many have occurred during the process.   */  public static SimpleNode parser(String filename)   {    SimpleNode start = null;        if (filename.length() < 1)    {      System.out.println("Please pass in the filename for a parameter.");    }        try    {		try		{	  		Parser parser = new Parser(new FileInputStream(filename));	  		start = parser.start();		}			catch (FileNotFoundException err)    	{        	System.err.println("-2: Entered file name is not corrent, check name and re-enter");        	System.err.println("You entered the file name as: \n" + err.getMessage());        	System.exit(-1);      	}     }          catch (ParseException e)     {      System.err.println("-1: The input file is not lexically/syntactically valid Minifun");      System.err.println("The Error occured because of: \n" + e.getMessage());      System.exit(-1);     }        return start;	   }  public static void print_AST(SimpleNode root, String prefix)  {    if (root != null)    {      if (root.value != null) System.out.println(prefix + root.value);      for (int i = 0; i < root.jjtGetNumChildren(); ++i)      {        SimpleNode n = (SimpleNode) root.jjtGetChild(i);        if (n != null)        {          print_AST(n, prefix + "   ");        }      }    }  }}PARSER_END(Parser)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* RESERVED WORDS */{  < DEFINE_KEYWORD : "define" >| < CONDITION_KEYWORD : "cond" >| < ELSE_KEYWORD : "else" >}TOKEN : /* Primitive Functions */{  < PRIMITIVE_FUNCTIONS : "+" 						| "-" 						| "*" 						| "/" 						| "=" 						| "<" 						| ">" 						| "<=" 						| ">=" >}TOKEN : /* TOKENS THAT REQUIRE REGULAR EXPRESSIONS*/{  < #DIGITS : [ "0"-"9" ] >| < VARIABLE : ([ "a"-"z", "A"-"Z", "_" ]) ([ "a"-"z", "A"-"Z", "-", "_" ])* >}TOKEN : /* BRACKETS */{  < LEFT_PARENTHESIS : "(" >| < RIGHT_PARENTHESIS : ")" >}TOKEN : /* CONSTANT */{  <	CONSTANT : (< DIGITS>)+			 |	"#t"  		     |  "#f" >}/* -------------------------------------------------------------------------------------- * <S>     ::= <pro> <EOF> * -- > the start() function represents the starting point of parsing ----------------------------------------------------------------------------------------*/SimpleNode start() #root :{}{  program() < EOF >  {    return jjtThis;  }}/* -------------------------------------------------------------------------------------- * <pro>   ::= <s_exp> <prog> * -- > the prog() function represents below the above grammar in javacc, since the above grammar *      is calling <prog> which is basically a recursive call so instead of representing *      it as same as above, I represented it by using the + operation which means to *		allow for 1 or more occurrences of the <s_exp>. ----------------------------------------------------------------------------------------*/void program() #void :{}{  (symbolic_expression())+}/* -------------------------------------------------------------------------------------- * <s_exp> ::= <def>  *			| <exp> * -- > the symbolic_expression() function below represents the above grammar in javacc. ----------------------------------------------------------------------------------------*/void symbolic_expression() #void :{}{  LOOKAHEAD(2)  define()| expression()}/* -------------------------------------------------------------------------------------- * <def>   ::= (<def> <def_P> * -- > the define() function below represents the above grammar in javacc. ----------------------------------------------------------------------------------------*/void define() #define :{  Token d;  Token e;  int arguments = 0;}{  LOOKAHEAD(3)  < LEFT_PARENTHESIS > d = < DEFINE_KEYWORD >  < LEFT_PARENTHESIS> e = <VARIABLE> (variable(){arguments++;})+ {jjtThis.value = e.image;}#var(arguments)< RIGHT_PARENTHESIS > expression()  {jjtThis.value = d.image;} < RIGHT_PARENTHESIS >| < LEFT_PARENTHESIS > d = < DEFINE_KEYWORD > {jjtThis.value = d.image;} variable() expression() < RIGHT_PARENTHESIS >}/* -------------------------------------------------------------------------------------- * <exp>   ::= <var> *			| <con> *			| (<exp_P>) * -- > the expression() function below represents the above grammar in javacc. ----------------------------------------------------------------------------------------*/void expression() #expression :{  Token e;  Token d;  int arguments = 0; }{  d = < VARIABLE >{jjtThis.value = d.image;}| d = < CONSTANT > {jjtThis.value = d.image;}| LOOKAHEAD(3) < LEFT_PARENTHESIS > d = <PRIMITIVE_FUNCTIONS> (expression())+ {jjtThis.value = d.image;} < RIGHT_PARENTHESIS >| LOOKAHEAD(3) < LEFT_PARENTHESIS > variable()(expression())+ < RIGHT_PARENTHESIS >| <LEFT_PARENTHESIS> d = < CONDITION_KEYWORD > (LOOKAHEAD(3) <LEFT_PARENTHESIS> expression() expression() <RIGHT_PARENTHESIS>{arguments += 2;})+ {jjtThis.value = d.image;}#cond(arguments) ( <LEFT_PARENTHESIS> e = <ELSE_KEYWORD> expression() {jjtThis.value = e.image;}#els(1) <RIGHT_PARENTHESIS>)? <RIGHT_PARENTHESIS>}/* ---------------------------------------------------------------------------------------- * Represents the grammar for the variables ------------------------------------------------------------------------------------------*/void variable() #variable :{Token t;}{  t = < VARIABLE > {jjtThis.value = t.image;}}