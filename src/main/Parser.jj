/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*//************************************************************************************************* Author: Devan Shah* Student ID : 100428864* Assignment: Assignment 3* Course: Programming Language and Compilers ENGR-3960U* Submitted to: Dr. Jorge Landa* Descriptions: In this assignment I have implemented the lexical and syntactic analysis of				Minifun programming language. The scanner splits up the inputs into tokens and				is used to catch lexical errors, which include invalid tokens that have been				inputed. The parser is used to check that the input list of tokens conforms to a				syntax that is specified with the use of the context-free grammar.************************************************************************************************/options{  STATIC = true;}PARSER_BEGIN(Parser)package main;import java.io.*;import java.util.*;public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected static JJTParserState jjtree = new JJTParserState();

/*@egen*/  /* main function that is used to start the parsing of the inputed file and also deliver   * any error messages that many have occurred during the process.   */  public static SimpleNode parser(String filename)   {    SimpleNode start = null;        if (filename.length() < 1)    {      System.out.println("Please pass in the filename for a parameter.");    }        try    {		try		{	  		Parser parser = new Parser(new FileInputStream(filename));	  		start = parser.start();		}			catch (FileNotFoundException err)    	{        	System.err.println("-2: Entered file name is not corrent, check name and re-enter");        	System.err.println("You entered the file name as: \n" + err.getMessage());        	System.exit(-1);      	}     }          catch (ParseException e)     {      System.err.println("-1: The input file is not lexically/syntactically valid Minifun");      System.err.println("The Error occured because of: \n" + e.getMessage());      System.exit(-1);     }        return start;	   }  public static void print_AST(SimpleNode root, String prefix)  {    if (root != null)    {      if (root.value != null) System.out.println(prefix + root.value);      for (int i = 0; i < root.jjtGetNumChildren(); ++i)      {        SimpleNode n = (SimpleNode) root.jjtGetChild(i);        if (n != null)        {          print_AST(n, prefix + "   ");        }      }    }  }}PARSER_END(Parser)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* RESERVED WORDS */{  < DEFINE_KEYWORD : "define" >| < CONDITION_KEYWORD : "cond" >| < ELSE_KEYWORD : "else" >}TOKEN : /* Primitive Functions */{  < PRIMITIVE_FUNCTIONS : "+" 						| "-" 						| "*" 						| "/" 						| "=" 						| "<" 						| ">" 						| "<=" 						| ">=" >}TOKEN : /* TOKENS THAT REQUIRE REGULAR EXPRESSIONS*/{  < #DIGITS : [ "0"-"9" ] >| < VARIABLE : ([ "a"-"z", "A"-"Z", "_" ]) ([ "a"-"z", "A"-"Z", "-", "_" ])* >}TOKEN : /* BRACKETS */{  < LEFT_PARENTHESIS : "(" >| < RIGHT_PARENTHESIS : ")" >}TOKEN : /* CONSTANT */{  <	CONSTANT : (< DIGITS>)+			 |	"#t"  		     |  "#f" >}/* -------------------------------------------------------------------------------------- * <S>     ::= <pro> <EOF> * -- > the start() function represents the starting point of parsing ----------------------------------------------------------------------------------------*/SimpleNode start()       :{/*@bgen(jjtree) root */
  SimpleNode jjtn000 = new SimpleNode(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) root */
  try {
/*@egen*/  program() < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/* -------------------------------------------------------------------------------------- * <pro>   ::= <s_exp> <prog> * -- > the prog() function represents below the above grammar in javacc, since the above grammar *      is calling <prog> which is basically a recursive call so instead of representing *      it as same as above, I represented it by using the + operation which means to *		allow for 1 or more occurrences of the <s_exp>. ----------------------------------------------------------------------------------------*/void program()       :{}{  (symbolic_expression())+}/* -------------------------------------------------------------------------------------- * <s_exp> ::= <def>  *			| <exp> * -- > the symbolic_expression() function below represents the above grammar in javacc. ----------------------------------------------------------------------------------------*/void symbolic_expression()       :{}{  LOOKAHEAD(2)  define()| expression()}/* -------------------------------------------------------------------------------------- * <def>   ::= (<def> <def_P> * -- > the define() function below represents the above grammar in javacc. ----------------------------------------------------------------------------------------*/void define()         :{/*@bgen(jjtree) define */
  SimpleNode jjtn000 = new SimpleNode(JJTDEFINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token d;  Token e;  int arguments = 0;}{/*@bgen(jjtree) define */
  try {
/*@egen*/  LOOKAHEAD(3)  < LEFT_PARENTHESIS > d = < DEFINE_KEYWORD >  < LEFT_PARENTHESIS> e = <VARIABLE> (variable(){arguments++;})+/*@bgen(jjtree) #var( arguments) */
                                                                                                              {
                                                                                                                SimpleNode jjtn001 = new SimpleNode(JJTVAR);
                                                                                                                boolean jjtc001 = true;
                                                                                                                jjtree.openNodeScope(jjtn001);
                                                                                                              }
                                                                                                              try {
/*@egen*//*@bgen(jjtree)*/
                                                                                                              {
                                                                                                                jjtree.closeNodeScope(jjtn001,  arguments);
                                                                                                                jjtc001 = false;
                                                                                                              }
/*@egen*/ {jjtn001.value = e.image;}/*@bgen(jjtree)*/
                                                                                                              } finally {
                                                                                                                if (jjtc001) {
                                                                                                                  jjtree.closeNodeScope(jjtn001,  arguments);
                                                                                                                }
                                                                                                              }
/*@egen*/               < RIGHT_PARENTHESIS > expression()  {jjtn000.value = d.image;} < RIGHT_PARENTHESIS >| < LEFT_PARENTHESIS > d = < DEFINE_KEYWORD > {jjtn000.value = d.image;} variable() expression() < RIGHT_PARENTHESIS >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/* -------------------------------------------------------------------------------------- * <exp>   ::= <var> *			| <con> *			| (<exp_P>) * -- > the expression() function below represents the above grammar in javacc. ----------------------------------------------------------------------------------------*/void expression()             :{/*@bgen(jjtree) expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token e;  Token d;  int arguments = 0; }{/*@bgen(jjtree) expression */
  try {
/*@egen*/  d = < VARIABLE >/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/{jjtn000.value = d.image;}| d = < CONSTANT >/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.value = d.image;}| LOOKAHEAD(3) < LEFT_PARENTHESIS > d = <PRIMITIVE_FUNCTIONS> (expression())+ {jjtn000.value = d.image;} < RIGHT_PARENTHESIS >| LOOKAHEAD(3) < LEFT_PARENTHESIS > variable()(expression())+ < RIGHT_PARENTHESIS >| <LEFT_PARENTHESIS> d = < CONDITION_KEYWORD > (LOOKAHEAD(3) <LEFT_PARENTHESIS> expression() expression() <RIGHT_PARENTHESIS>{arguments += 2;})+/*@bgen(jjtree) #cond( arguments) */
                    {
                      SimpleNode jjtn001 = new SimpleNode(JJTCOND);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                    }
                    try {
/*@egen*//*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn001,  arguments);
                      jjtc001 = false;
                    }
/*@egen*/ {jjtn001.value = d.image;}/*@bgen(jjtree)*/
                    } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  arguments);
                      }
                    }
/*@egen*/                 ( <LEFT_PARENTHESIS> e = <ELSE_KEYWORD> expression()/*@bgen(jjtree) #els( 1) */
                                                                                                                    {
                                                                                                                      SimpleNode jjtn002 = new SimpleNode(JJTELS);
                                                                                                                      boolean jjtc002 = true;
                                                                                                                      jjtree.openNodeScope(jjtn002);
                                                                                                                    }
                                                                                                                    try {
/*@egen*//*@bgen(jjtree)*/
                                                                                                                    {
                                                                                                                      jjtree.closeNodeScope(jjtn002,  1);
                                                                                                                      jjtc002 = false;
                                                                                                                    }
/*@egen*/ {jjtn002.value = e.image;}/*@bgen(jjtree)*/
                                                                                                                    } finally {
                                                                                                                      if (jjtc002) {
                                                                                                                        jjtree.closeNodeScope(jjtn002,  1);
                                                                                                                      }
                                                                                                                    }
/*@egen*/        <RIGHT_PARENTHESIS>)? <RIGHT_PARENTHESIS>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/* ---------------------------------------------------------------------------------------- * Represents the grammar for the variables ------------------------------------------------------------------------------------------*/void variable()           :{/*@bgen(jjtree) variable */
 SimpleNode jjtn000 = new SimpleNode(JJTVARIABLE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) variable */
  try {
/*@egen*/  t = < VARIABLE >/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}